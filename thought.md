## 所遇到的坑

### 1.reactive()中定义的对象再次赋值，页面不会自动更新

刚开始写vue3的时候只要是页面展示的对象第一反应就是使用reactive。直到后面在axios里面请求数据时，因为后端返回的数据是对象包裹的，我便顺手将对象直接赋值给reactive出来的对象，具体操作如下

```
/*模板*/
<div>
{{data.name}}
</div>

//js
let data=reactive({name:"张三"})
data=function(){
	数据请求地址等...
	return res 		//res是请求过来的数据{name:"李四"}
}
```

data是reactive的页面能响应式，最开始直接我改变了直接data再次赋值，页面并不会刷新。也就是说div里面的张三没有变成李四。咦！响应式了但是没有完全响应式。

**解决办法:**

1.将reactive换成ref，即可实现页面随时刷新

2.在定义reactive的时候，定义属性名，在后期赋值的时候，对属性名进行赋值；

操作如下：

```
方法1)
let data=ref({})
data.value=function(){
	数据请求地址等...
	return res 		//res是请求过来的数据{name:"李四"}
}

方法2)
/*模板*/
<div>
{{data.value.name}}
</div>

//js
let data=reactive({value:{}})
data.value=function(){
	数据请求地址等...
	return res 		//res是请求过来的数据{name:"李四"}
}
```

**总结：**

reactive 通过proxy代理对象里面的属性。当你用reactive创建时他会创建一个proxy对象。在使用对象里面的属性时会通过get收集被使用属性有哪些并将它们存放在WeakMap里面(收集依赖)，当你改变proxy里面的值是会走set，而set会先将值改变，然后去WeakMap里面寻找有无当前的属性属性，如果有则重新渲染页面，没有则只改变值并不会更新页面。

为什么会造成这种情况呢？原因是上面的操作是直接修改了整个对象，根本不会走set方法，也不会去WeakMap里面查找依赖，所以不会更新页面。

补充ref源码：当创建ref时。1、底层会创建一个对象，对象里面有个value属性用于接收ref括号里传进来的值。在赋值之前先判断是不是对象或者数组类型，如果是对象或者数组那么就调reactive，不是则不做任何处理。不管是不是对象或者数组，最后都会将处理完的值传给value属性。2、在对象里添加get value和set value。在使用时会进入get，收集相关依赖(收集方式和reactive差不多)然后返回value的值。在改变值时会进入set，会将value存放在rawValue属性里，然后用rawValue和要新值做对比如果一样不做任何操作。不一样则判断新值是否为对象或者数组并决定是否调用reactive(和创建之初一样)将处理好的值给到value。

当模板使用ref时不用加value就可以使用，他底层就是调用了proxyRef,这个方法接受一个参数，该参数为ref类型(传进来后用obj接收)。里面会返回一个proxy对象。因为是proxy那么有get和set，get时会返回	obj.value。这样就可以不用自己手动调用.value。set时也是会在里面obj.value=新的值也不用手动.value

### 2.dom更新后操作nextTick

nextTick使用场景在 vue 中数据发生变化后，dom 的更新是需要一定时间的，而我们在数据更新之后就立即去操作或者获取 dom 的话，其实还是操作和获取的未更新的 dom ，而我们可以调用 nextTick拿到最新的 dom

其实这个也不算是坑，完全怪我当成学习vue时没有去了解nextTick。

**具体场景**关于文字是否滚动的问题：当文字超出指定宽度就开始滚动。那么怎么发现有无超出，那就得监听dom的宽度变化。之前我是直接在文字发生改变就直接获取到dom的宽度(此时dom没有更新完毕，我拿到的还是之前的dom宽度)，这样拿到的宽度并不准确，所以必须在更新后再去获取dom宽度那就必须用到nextTick。具体实现文件在components下的scorllText.vue

### 3.flex遇到的坑

子盒子添加了flex:1;可以占满剩余空间。孙盒子宽高都设置百分百，你会发现孙盒子的宽度不受父盒子影响，甚至当孙盒子内容过多时还会将子盒子撑大。

**解决方法**：给孙盒子添加绝对定位即可 

### 4.provide和inject不能异步的问题

provide只能在setup的最上层发送，不能在异步里面发送。所以会出现一个问题，像请求到的接口数据provide不能传。

为了解决这个问题可以让provide传递一个ref值，在接口响应后将接口返回的值给ref。那么即可达到响应效果。具体效果可以查看用户主页传递到popup.vue的useData数据

![image-20220905110905840](./readmeImage/image-20220905110905840.png)

### 5.vue将系统标签当成组件解析

在使用marquee时vue将该标签当成组件来解析并抛出错误

![image-20221003165233124](D:\前端\vue3\项目\网易云\vue-project\readmeImage\image-20221003165233124.png)

**解决办法：**

![image-20221003165112007](D:\前端\vue3\项目\网易云\vue-project\readmeImage\image-20221003165112007.png)

## 学习到的新东西

 ### 1.vue3的hooks

hooks和vue2的mixin 使用场景差不多，hooks是函数可以提高代码的复用性，能够在不同的组件当中都利用 hooks函数。因为可以引入vue文件所以还可以实现<u>**组件的传参，可以操控任意组件的状态**</u>

**使用场景**

loading组件

```
/*模板*/
<div v-show="loadingShow"></div>
//js
import {controlLoad,loadingShow} from "@/hooks/controlLoading.ts"   //控制loading
```

controlLoading.ts  (hooks文件)

```
import { ref } from "vue";

  export let loadingShow=ref(true)      //为true表示打开load
  //是否打开loading
  export const controlLoad=(setload:boolean)=>{
    loadingShow.value=setload
  }
```

修改loading的组件(当图片加载完毕，关闭loading效果)

```
/*模*/
<img @load=controlLoad(false)/>
//js
import {controlLoad,loadingShow} from "@/hooks/controlLoading.ts"   //控制loading
```

后代组件传参可以使用provide和inject。这里的组件传参指的没有结点关系(可以理解为堂兄之间的传参)。

感觉说的不是太清楚。可以查看我的源码，其中歌曲文件songControl里面实现了“操控任意组件的状态”

很多页面都用了loading的可以去看下具体实现



### 2.h5文字滚动标签marquee

这个标签可以拿来做标题，当标题的文字超出标题大小时可以将文字进行滚动处理(香啊)。具体代码可以看components下的scrollText.vue文件，我已经封装好了

### 3.设计模式

在网络请求方面使用了<u>工厂模式</u>，封装了两种请求一种是要带令牌的，一种是不需要令牌的，传递不同的参数发送不同的请求，再传入相应的参数处理函数

在歌曲的切换上面使用了<u>策略模式</u>，因为过多的if让代码可读性比较差，我将代码抽离出来通过下标来执行不同的方法具体代码在stores文件下的songPlay.ts里页面切换动画也采用了策略模式。具体代码在hooks文件下的pageAnimate.ts里

### 4.反向代理

解决问题：浏览器出现的跨域错误

原理:产生一个代理的服务器，代理服务器所在的位置和项目所在的位置一致，你向代理服务器发请求就不会产生跨域问题。而代理服务器向正真的服务器发送请求，并将请求返回到项目里(服务器对服务器不会产生跨域)

在vite.config.ts里配置

![image-20220810185005831](./readmeImage/image-20220810185005831.png)

### 5.pinia插件的封装

为了避免数据丢失，当用户点击了歌曲播放，我将整个歌曲仓库放到本地存储里面，在下次用户进入时，可以获取到上次播放的歌曲url和 歌曲信息。因为我歌曲的管理是放在useSong.ts的pinia仓库里面，可以通过监听仓库值的变化来将仓库放入本地存储。每次进入页面，去本地取出上次的值给到useSong里

![image-20220811170112050](.\readmeImage\image-20220811170112050.png)

其核心就是在调用$subscribe,这个api可以监听到pinia的变化

### 6.IntersectionObserver盒子重叠监听

该方法可以做<u>下拉加载、懒加载、滚动动画</u>。其原理就是监听子盒子是否进入到父盒子，满足进入到父盒子后的比例就会触发方法

![image-20220816091656378](.\readmeImage\image-20220816091656378.png)

[具体可以观看该博客](https://juejin.cn/post/6844903874302574599)

> 改方法建议在onUpdated里使用

### 7.scroll-behavior: smooth;平滑滚动样式

以前在a标签做锚点时，点击a标签滑动过于僵硬。为了滑动不僵硬一般是写的js。现在直接在要滚动的盒子上设置scroll-behavior: smooth;样式就可以实现平滑滚动。

### 8.v-model新特性

如果子组件要修该父组件的内容可以通过发送自定义事件并传个参数，再通过父组件方法进行修改值。为了修改一个值这样有点麻烦。那么可以使用v-model

可以定义多个v-model，定义方式为v-model:**名称**='绑定的值'。组件内defineProps接收必须以**名称**接收参数。可以通过发送事件 emit('update:名称**', 值)来修改父组件绑定的v-model值。

如果没写名称，那么defineProps接收时用modelValue来接收,修改emit('update:modelValue', 值)

[具体可以观看该博客](https://xiaoman.blog.csdn.net/article/details/123187523)

### 9.vmin适配

之前移动端使用的是vw，但是当屏幕横过来时并不会适配。为了解决可以使用vmin。

其底部原理，取到宽高谁最小谁做的当参照。

> 当然。一个页面盒子的最外层还是得用vw来给宽度

### 10动态路由

当用户登录后才可以跳转到指定页面。没有登录的话则没有该路由。可以在用户登录后动态添加路由

语法：router.addRouter({path:'/路由',name:名称,component:组件})

当用户退出登录后router.removeRoute('名称')删除路由

### 11.align-self

父盒子设置了display：flex;

子盒子设置align-self可以单独纵向排列

![image-20220830144900541](./readmeImage/image-20220830144900541.png)

>一般骰子是这样制作的

### 12.换肤功能

- 首先定义一个全局的css变量：以--开头的变量。如--color:red;

- 使用变量通过var函数使用定义好的变量。如color:var(--color);   **var函数除了使用外还可以定义全局变量。如color:var(--color,red)。这里定义了--color值为red**

- 在vue模板中使用全局属性

- 通过js的改变定义的全局属性的值。如document.documentElement.style.setProperty('全局属性',"值")

  >setProperty可以修改css的所有属性，不仅限于修改全局属性

### 13.自定义指令

在每个需要用户登录的按钮那里绑定一个指令。当用户没有登录，想要使用功能时就要求用户必须登录。如果登录了就执行原本按钮的功能。

注册指令方法

**局部注册**：在vue里面引入两个类型，Direactive、DirectiveBinding。第一个是自定义指令的约束类型。第二个是自定义属性传过来参数的类型。而且自定义指令命名必须以v开头。自定义指令也有生命周期created到updated

![image-20220831164214695](./readmeImage/image-20220831164214695.png)

![image-20220831164259801](./readmeImage/image-20220831164259801.png)

**全局注册**：全局注册比局部多了一步，不用以v开头并且要通过direactive挂载到vue上

![image-20220831164537392](./readmeImage/image-20220831164537392.png)

`当名字一样时局部会覆盖全局`

### 14.事件循环

**事件循环就是浏览器渲染主线程的工作方式**；因为js是单线程，运行在浏览器的渲染进程的主线程上面，而渲染的主线程不光有js要执行还要执行页面的渲染等。如果此时的js是同步执行的话，遇到网络请求和定时器之类的就会造成阻塞和页面的卡死。为了避免上述情况，浏览器使用了异步的方式来处理。当遇到定时器之类的任务时，主线程则立即停止这个任务，将这些任务交给其他线程来做。等其他线程完成时，再将定时器传递的回调函数包装成任务放到消息队列的末尾，等待主线程的调用。在谷歌浏览器中写了一个for的死循环，每当主线程执行完毕就会去消息队列里面提任务出来执行。

消息队列：说到消息队列，以前的消息队列有宏队列和微队列。现在的消息队列有微队列、交互队列、时间队列，微队列最高，时间队列最低。每次主线程执行完毕都会优先去微队列里面找任务。根据w3c的标准任务分为多种类型，相同任务在同一个队列，不同任务在不同队列<u>(比如定时器只能在时间队列不能在交互队列里)</u>

### 15.浏览器渲染原理

在url输入地址后敲回车主要会做网络和渲染方面的事

渲染原理：主要在浏览器的渲染进程里的**渲染主线程（1-5）**和**合成线程（6-8）**里面完成

1）解析html

​	在网络后可以拿到html的字符文件。主线程开始解析html。dom成为dom树，css成为css树（<u>css解析不会阻塞，因为在解析css的时候工作会在预解析线程里面</u>），但是遇到js后会停止其他解析执行完js的全局代码后继续向下解析（<u>因为js里面可能会有修改dom的操作，由此推荐将js放到文件的末尾</u>）

2）计算

​	遍历dom树，计算样式将最后得到的样式放到dom树上。

3）布局

​	这一步是最消耗时间的。他会将带有css的dom树。通过几何信息计算出一个新的布局树，他们两者并不是一一对应的，比如说当dom树上的样式有display：none这样的元素或者添加了伪元素选择器就会使得他们不同。

> 重排：修改dom几何信息会产生重排，重排会重新走布局，并继续执行后续其他步骤

4）分层

​	为了减少更新，浏览器对布局树进行分层。当那一层变了就只会更新对应层的东西，不会影响到其他层。分层可以通过will-change来影响分层  `分层不可直接操控，影响不一定会变为最终结果`

5）绘制

​	分层之后开始绘制，这里的绘制不是直接将dom展示出来。绘制会给每个分层产生一个绘制指令集合。

> 重绘：重绘在这一步,因为重绘已经是布局后了，所以相对来说影响比较小。重排一点会重绘



6）分块

​	绘制完毕后主线程结束，将每个图层的绘制指令给到合成线程。合成线程从线程池里面取出线程进行分块，将区域划分更小。

7）光栅化

​	合成线程将快给到GPU进程，GUP会先处理靠近可视区的快。以极高的速度完成光栅化。得到的结果就是一块一块的位图，并给到合成线程

8）画

​	当合成线程拿到位图后会生成一个个指引信息，再把指引信息给GPU进程，由GPU进程提交给GUP硬件，完成最终的屏幕成像。



## 反馈

本人学生一枚在读大三，代码有很多地方不完善，如果有更好的建议或优化可以反馈给我。qq1251098491